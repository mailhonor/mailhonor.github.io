---
layout: wiki
title:  HONOR-SPAM 中文邮件反垃圾系统
---

<p>honor-spam 是一个基于智能学习的中文邮件反垃圾系统. 支持中文简体,繁体,日文,韩文,越南文,等文字.

<p>honor-spam 是开源软件. 代码仓库:
<A target="_blank" href="https://github.com/mailhonor/honor-spam.git">https://github.com/mailhonor/honor-spam.git</A>

<p>百度网盘下载程序和反垃圾库:
<A href="http://pan.baidu.com/s/1hrfROqw" target="_blank">http://pan.baidu.com/s/1hrfROqw</A>

<H2>安装过程</H2>
<p><i><B>请注意</B>: 有些系统自带HONOR-SPAM,如<A href="./honor-milter.html">HONOR-MILTER 反垃圾邮件网关</A>,如果已经安装这些系统,则请忽略此"安装过程"</i>
<p>分两步: 1) 安装运行程序, 2) 安装最新反垃圾库.
<H3>安装运行程序<small><i> &nbsp;
(只支持64位Linux系统, <a href="#srcinstall">源码安装</a>)</i></small></H3>
<ul>
    <li>下载得到 <B> honor_milter.tgz </B> </li>
    <li>创建目录 <B> /opt/honor_milter/ </B>, 进入其中 </li>
    <li>解开honor_milter.tgz 即可</li>
</ul>

<H3>下载最新反垃圾库</H3>
<ul>
    <li>下载最新版 const-(version).db.gz, 建议备份</li>
    <li>解开得到 const.db, 移动到 /opt/honor_milter/spamdb/const.db</li>
</ul>

<H3>启动/停止/重启</H3>
<pre>
./libexec/honor_milter.sh start/stop/reload/restart
</pre>


<H2>文件目录说明</H2>
<table class="listtb">
<tr>
    <td width="300"><B>/opt/honor_milter/</B></td>
    <td>系统默认安装路径, 服务运行时路径.</td>
</tr>
<tr>
    <td><B>./config/spamd.cf</B></td>
    <td>反垃圾程序配置文件</td>
</tr>
<tr>
    <td><B>./spamdb/const.db</B></td>
    <td>反垃圾库,只读,高速.</td>
</tr>
<tr>
    <td><B>./spamdb/train.db</B></td>
    <td>反垃圾库,用于训练(回馈,喂养).速度较慢,实际上是sqlite3.<br>
    </td>
</tr>
<tr>
    <td><B>./libexec/master</B></td>
    <td>服务管理程序.</td>
</tr>
<tr>
    <td><B>./libexec/spamd</B></td>
    <td>反垃圾主程序</td>
</tr>
<tr>
    <td><B>./libexec/honor_milter.sh</B></td>
    <td>启动/停止/重启 脚本</td>
</tr>
<tr>
    <td><B>./libexec/spam_admin</B></td>
    <td>一个命令工具,<A href="#spam_admin">详细</A></td>
</tr>
</table>

<H2>配置文件 ./config/spamd.cf</H2>
<pre>
zcmd = libexec/spamd 

#反垃圾服务监听地址.这里请注意,反垃圾服务必须和milter服务在同一台电脑上.
zlisten = 127.0.0.1:32502

zproc_limit = 1

# 工作线程数
concurrency_limit = 8

# 只读反垃圾库
spam_constdb = spamdb/const.db

# 可写反垃圾库(用于训练，反馈）
spam_traindb = spamdb/train.db

#threshold #阈值, 参考值, 反垃圾得分大于等于threshold则给出关键字 <B>bad spam</B>, 否则给出关键字 <B>good</B>
threshold = 0.7
</pre>

<H2>如何识别垃圾邮件</H2>
<p>服务器的默认服务端口是 127.0.0.1:32502

<H3>识别流程(通信协议)</H3>
<pre>
1. 连接: <B>127.0.0.1:32502</B>
2. 输入: <B><u>score</u>[一个空格]邮件文件路径\n</B>
3. 返回: <B>OK 得分 关键字\n</B>
4. 客户端关闭连接 或 回到 2
</pre>

<p>所谓 <b>"邮件文件路径"</b> 形如 /opt/mail/storage/some1.eml
<br>系统假设:客户端提供的任何文件都是邮件且可读.
<p>所谓 <b>"得分"</b> 形如 0.700268, 介于0.000000 ~ 1.000000 之间,越接近1.0,是垃圾邮件的可能性越大.
<br>根据得分,由使用者来最终确定是不是垃圾邮件.
<br>根据作者实际经验,大于0.7的是垃圾邮件,小于0.4为正常邮件.
<p>所谓<b>"关键字"</b>, 如果得分大于等于threshold则为"bad spam",否则为"good".

<H3>例子: 邮件/opt/mail/storage/u1.eml 的得分</H3> 
<pre>
输入: <b>score /opt/mail/storage/u1.eml\n</b>
返回: <b>OK 0.212383 good\n</b>
</pre>

<H3>php 例子 --- 得分</H3>
<textarea class="code">
<?php
$host = "localhost";
$port = 32502;
$threshold_bad = 0.7;
$threshold_good = 0.4;

function get_score($fp, $eml_fn)
{
    global $threshold_bad, $threshold_good;

    fputs($fp, "score $eml_fn\n");
    $data = @fgets($fp);

    if($data === false)
    {
        return Array("error", "");
    }

    $tmp = explode(' ' , trim($data));
    $score = $tmp[0];
    if($score > $threshold_bad)
    {
        return Array("bad", $score);
    }
    if($score < $threshold_good)
    {
        return Array("good", $score);
    }
    return Array("unknown", $score);
}

$fp = fsockopen($host, $port);
if(!$fp)
{
    echo "can not open spamd at $host:$port\n";
}

for($i=1;$i<$argc;$i++)
{
    $result=get_score($fp, $argv[$i]);
    echo $result[0], "\t", $result[1], " ", $argv[$i], "\n";
}
</textarea>


<H2>如何回馈/训练/喂养垃圾邮件和正常邮件</H2>

<pre>
1. 连接: <B>127.0.0.1:32502</B>
2. 输入: <B><u>命令</u>[一个空格]邮件文件路径\n</B>
3. 返回: <B>OK\n</B> 或 <B>ERR\n</B>
4. 客户端关闭连接 或 回到 2
</pre>
<p>所谓 <b>"命令"</b> 包括: good, bad
<p>所谓 <b>"邮件文件路径"</b> 形如 /opt/mail/storage/some1.eml
<br>系统假设:客户端提供的任何文件都是邮件且可读.

<H3>例子: 训练 邮件/opt/mail/storage/u2.eml 为正常邮件</H3> 
<pre>
输入: good /opt/mail/storage/u2.eml\n
返回: OK\n 或: ERR\n
</pre>


<H3>例子: 训练 邮件/opt/mail/storage/u3.eml 为垃圾邮件</H3>
<pre>
输入: bad /opt/mail/storage/u3.eml\n
返回: OK\n 或: ERR\n
</pre>

<H3>php 例子 -- 训练</H3>
<textarea class="code">
<?php
$host = "localhost";
$port = 32502;

function train_do($fp, $good_or_bad, $eml_fn)
{
    fputs($fp, "$good_or_bad $eml_fn\n");
    $data = @fgets($fp);

    if($data === false)
    {
        return false;
    }

    $res = trim($data);
    return $res;
}

if ($argc < 3)
{
    echo "USAGE: ",$argv[0]," good/bad eml_fn_list...\n";
    die();
}
$good_or_bad = $argv[1];

$fp = fsockopen($host, $port);
if(!$fp)
{
    echo "can not open spamd at $host:$port\n";
}

for($i=2;$i<$argc;$i++)
{
    $result=train_do($fp, $good_or_bad, $argv[$i]);
    echo $result, "\n";
}
</textarea>


<H2 id="reloaddb">重新加载反垃圾库,而不重启服务</H2>
<pre>
1. 连接: <B>127.0.0.1:32502</B>
2. 输入: <B><u>reloaddb</u>\n</B>
3. 返回: <B>OK\n</B> 或 <B>系统异常,程序退出</B>
</pre>

<H2 id="spam_admin">spam_admin 管理工具使用说明</H2>

<H3> 先看下USAGE</H3>
<textarea class="code">
$ ./libexec/spam_admin 
USAGE:
  ./libexec/spam_admin good        traindb                   eml_file/eml_dir
  ./libexec/spam_admin bad         traindb                   eml_file/eml_dir
  ./libexec/spam_admin test        db [ db2 [ ...]]          eml_file/eml_dir
  ./libexec/spam_admin view        eml_file                                  
  ./libexec/spam_admin segment     eml_file                                  
  ./libexec/spam_admin charset     filename                                  
  ./libexec/spam_admin merge_db    constdb_or_traindb        traindb         
  ./libexec/spam_admin convert_db  traindb                   new_constdb
</textarea>
<ul>
<li>good/bad/test/view/segment/charset/merge_db/convert_db 是第一个参数,表明功能.</li>
<li>constdb 表示一个只读的数据库文件.</li>
<li>traindb 表示个可写的数据库文件(sqlite3).</li>
<li>eml_file 表示一个邮件文件.</li>
<li>eml_dir 表示一个目录,其下(及递归子目录下)的文件为邮件</li>
</ul>

<H3>good: 训练正常信件</H3>
<pre>
./libexec/spam_admin good a.tdb ./a.eml
./libexec/spam_admin good a.tdb /spam/emls/good/
</pre>

<H3>bad: 训练垃圾信件</H3>
<pre>
./libexec/spam_admin bad a.tdb ./b.eml
./libexec/spam_admin bad a.tdb /spam/emls/bad/
</pre>

<H3>test: 测试信件得分</H3>
<p>获得一个目录(/spam/emls/test/)下所有邮件的得分.
<pre>
./libexec/spam_admin test a.tdb /spam/emls/test/
</pre>

<p>获得一个目录(/spam/emls/test/)下所有邮件的得分, 更多反垃圾库.
<pre>
./libexec/spam_admin test a.tdb b.tdb c.tdb d.cdb e.cdb...  /spam/emls/test/
</pre>

<p>获得一个邮件的得分, 并且给出更详细的得分信息.
<pre>
./libexec/spam_admin test a.tdb b.tdb c.tdb d.cdb e.cdb...  /spam/emls/test/someone.eml
</pre>

<H3>view: 查看信件</H3>
<p>解开一封信件, 返回非常详细的信件信息.
包括主题,发件人,收件人,...,正文,附件名,...mime格式等.
<br>并且会把可读信息信转为UTF-8
<pre>
./libexec/spam_admin view /somepath/somepath2/a.eml
</pre>

<H3>segment: 信件分词</H3>
<p>对一封信件,做分词(切词)操作,查看分词结果,用于调试.
<pre>
./libexec/spam_admin segment /somepath/somepath2/a.eml
</pre>

<H3>merge_db: 合并数据库</H3>
<p>把一个反垃圾数据库(既可以是constdb,也可以是traindb), 合并到一个traindb.
<pre>
./libexec/spam_admin merge_db a.cdb dest.tdb
./libexec/spam_admin merge_db b.tdb dest.tdb
</pre>
<p>如果 dest.tdb不存在,会创建一个.

<H3>convert_db: 数据库格式转换</H3>
<p>把一个traindb转换为constdb.因为constdb比traindb快的多得多.
<pre>
./libexec/spam_admin convert_db a.tdb a.cdb
</pre>
<p>a.cdb如果不存在,则创建一个,否则被覆盖.

<H2>维护反垃圾库的一些建议</H2>
<p>先说明,本系统即可以实时训练邮件,也可以手动维护.
<p>如果在单机系统且规模较小(如1000邮件用户内),可通过服务端口实时训练,问题不大.
<p>如果在多机环境或规模很大,不建议实时训练,sqlite3的写性能会成为瓶颈.

<h3>模型 1 (仅供参考)</h3>
<pre>
1. 下载最新版反垃圾库 命名为:A
2. 维护一个文件夹,其中存放较老较固定的邮件(回馈的或收集的正常和垃圾邮件), 用spam_admin训练为反垃圾库 命名为: B
    2.0 删除 B
    2.1 ./spam_admin good B somepath1_or_file1
        ......
    2.2 ./spam_admin bad B somepath2_or_file2
        ......
3. 维护另一个文件集,其中存放近期添加的邮件(回馈的或收集的正常和垃圾邮件), 用spam_admin训练为反垃圾库 命名为: C
    3.0 同 第2条
4. 用spam_admin 合并A B C 为一个新的<i>训练</i>库, 命名为: D
    4.0 删除 D
    4.1 ./spam_admin merge_db A D
    4.2 ./spam_admin merge_db B D
    4.1 ./spam_admin merge_db C D
5. 用spam_admin 把 D 转换为只读库 E
    5.1 ./spam_admin convert_db D E
6. 移动 E 到 ./spamdb/const.db
7. 重启系统即可. 或 使spamd程序<A href="#reloaddb">重新加载</A>反垃圾库.
</pre>

<H2 id="srcinstall">从源码安装程序</H2>

<H3>首先安装libzc</H3>
<pre>
git clone https://github.com/mailhonor/libzc.git
cd libzc
make
</pre>
得到 <B>libzc.a , libzc.h</B>,备用

<H3>其他依赖的公共库</H3>
<pre class="code">
libgsl0-dbg libgsl0-dev libgsl0ldbl libssl libssl-dev libsqlite3 libsqlite3-dev
</pre>

<H3>安装主程序honor-spam</H3>
<pre>
git clone https://github.com/mailhonor/honor-spam.git
cd honor-spam
复制上面提到 "libzc.a , libzc.h" 到当前目录.
make
make install
</pre>

<H2>相关文章</H2>
<ul>
    <li><A href="./honor-milter.html">HONOR-MILTER 反垃圾邮件网关</A></li>
    <li><A href="./antispam-bayes.html">贝叶斯(Bayes)算法模型</A></li>
</ul>
